+++
title = "future me will thank me for my dev setup!"
slug = "dev"
date = 2026-02-01
+++

[Prime's My Dev Setup Is Better Than Yours][1] stuck with me: your setup is best
for you because *it's yours* - custom built for how you work. I tried
[mocking it][mockdev] with sparse commits here and there. The real kick was
changing jobs last year which means new laptop and new vigor to
create my "dev setup". Instead of bikeshedding and analysis paralysis, I went
brrr and built a workflow on shoulders of giants. This is production grade
software where production is "works on my machine :P".

Hence, with an obligatory XKCD reference, I tagged 1.0 for
[sudo make me a sandwich](https://github.com/hrmnjt/dev) i.e. my "dev setup"
which is working really well (for now). Hence, future Harman will thank current
`epoch: 1769955510` Harman, for organizing the dev setup and writing a few words
about it. In a nutshell:
- `brew bundle` manages the bottles and casks that I need
- `just` reduces the number of bash script needed
- `stow` manages the dotfiles

## choosing Homebrew and `brew bundle`

The first version of `dev` repo had install scripts which will pull the binaries
from internet and install them based on the type of binary that I would get. And
I was in for a treat when I was trying to install a `.dmg` or a `.pkg` file!
MacOS doesn't have an inbuilt programmatic approach to install compared to
`dpkg` or `apt` which I'm well versed with. MacOS wants its users to be dumb and
deliberately do clickops to install and configure stuff. It was a jarring
experience overall and suddenly the script started looking crazy long full of
different conventions (a) no checksum (b) managing versions (c) validating
install after copying stuff (d) handle `.app` bundles or manage `.pkg`
installers. This reminded me of Flatpak/AppImage drama on Linux minus the
traction.

Meanwhile, on a daily basis I was still going strong with `brew install ...`
which was ergonomic, clean and simple. Although, there is a different issue with
Homebrew (a) I need to install that first (b) I had to create a mental model
around brew commands. I found myself using the manpage and `brew --help` too
often. `brew bundle` however can be used to install most tools - tui, cli, or
gui.

I don't like this approach but I can make do with it because it is declarative
and "it just works". Nix seems to be the closest thing to "proper package
management" on MacOS, but it's solving a problem Apple doesn't want to solved,
so seems there is going to be friction. Also, a steep learning curve for me.


## `just` vs `make`

For this project, `just` and `make` are task-runners. I pick a project, work on
it and then leave it as is for months; when I come back, I've forgotten how to
do chores e.g. following. Task runners solve this problem.
- Do I need to update `Brewfile` first?
- Or should I install the tool with `brew install ...` and then check
if `Brewfile` is updated?
- That other time, I just installed `jq` and my `Brewfile` doesn't know I need
it always!
- How to bootstrap this new macbook? What steps did I take last time?

`make` is a build system which happens to work as a task runner. And for most
developer machines `make` is always present. For MacOS, `make` is present after
`xcode-select --install` --- which is the first thing most developers do after
getting a new Mac. Despite these merits, I didn't invest a lot of time and
effort into learning `make`. `just` was simple, easier and I had used it in
past. So, I went with `just` for this repo even though it requires an install.
In recent future, I wish to spend a weekend and learn `make` and its quirks
(I know some!) and ditch `just` for this project.


## stumbling upon `stow`

I've seen countless option for dotfile management. And I've seen so many
handrolled solutions to manage dotfiles. My requirement for dotfiles is very
simple i.e. copy the files to `XDG_CONFIG_HOME`. I found `stow` in a HN thread
and earmarked it to try when I want to do dotfiles. I don't use 90% of things
`stow` can do but what I needed was good enough and very ergonomic.

## desires and wishes

There are many improvements which I've not detailed out quite. 2025 Harman would
have created a list of TODOs which would give him "Phantom Obligation"[^3].
Today, however, I'm choosing to dump my raw thoughts here and address it when I
address it.

**Improvement 1: simpler bootstrap steps**:

As of [02d2867][02d2867], the bootstrap requires me to install homebrew, install
`just` and `stow` using homebrew, clone this repo, define `XDG_CONFIG_HOME`[^1],
and install required software using `brew bundle` and configure most of them
with `stow`. That leaves out folder structure for Git and SSH key generation for
Github.


If I spend some energy learning `make` and its idiosyncracies, I can ditch
`just`. And if I write a shell script to overwrite partially or completely the
`.config` that I create, I can ditch `stow`. Since my dev setup is on a public
Github repo (and will be public forever, I guess), can clone it using HTTPS for
the first time on `/tmp` directory and just go brrr with the setup e.g. to
create `XDG_CONFIG_HOME`, folder structure for Git, `brew bundle` and force
updating dotfiles.

Since I don't buy a Macbook so often, this improvement doesn't provide the ROI
required.

[^1]: While writing this post I learned that, Apple/NeXTSTEP conventions
(circa:1989) predate XDG Base Directory specifications (circa:2003) and latter
was created to solve the chaos in Linux ecosystem and has community-driven
voluntary enforcement. Since, I run Linux on servers, I prefer to follow this
convention and want to do the same on my MacOS machines for low cognitive load.

**Improvement 2: make it work for my servers too**: I don't buy Macbooks too
often, but I create and delete Linux servers too often. Right now, my setup
implies only local setup and not servers. I still largely use Claude Code on my
server to set them up and manage installations. Solving this problem will
actually make me saner. I've some ideas where I can test them up with ephemeral
machines[^2]

[^2]: [exe.dev](https://exe.dev/) and [Sprites](https://sprites.dev/) are 2 new
projects that I learnt about last week and both of them seem super interesting
to run and re-run random scripts to refine my dev setup with ease.

**Improvement 3: missing configurations**: I use `ripgrep`, `fzf`, `direnv` and
many more other tools but I use them raw. I should spend some time and integrate
`fzf` well into the workflow instead of manually adding flags.

**Improvement 4: smaller neovim configuration**: Right now, I use
`kickstart.nvim` and I've been using it for some time. I understand neovim well
enough to use a simpler and modular neovim configuration. But I've been too lazy
to get to doing this.

**Improvement 5: Nix for package management** 

Napkin math tells me this will be more for me to learn Nix than to actually give
me an ROI on my dev setup. So, I will park this one for as long as I don't get
any other reason to try Nix, NixOS or NixPkgs. And if I have to, maybe I will
consider using Arch and the awesome community that is coming up around it.


[^3]: I read this amazing article about feed readers UX creating a sense of
urgency to read an article and coin the word that suits this behavior I've
demonstrated in past. [Phantom Obligation](https://www.terrygodier.com/phantom-obligation)

[1]: https://frontendmasters.com/courses/developer-productivity-v2/introduction/
[mockdev]: https://github.com/hrmnjt/dev/tree/0.0.1
[02d2867]: https://github.com/hrmnjt/dev/tree/02d28676bf9fb39f83db61b80a7560914248bb8f


EOF